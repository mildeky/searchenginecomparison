'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _fibersFuture = require('fibers/future');

var _fibersFuture2 = _interopRequireDefault(_fibersFuture);

var _fibers = require('fibers');

var _fibers2 = _interopRequireDefault(_fibers);

var _objectAssign = require('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var __$Getters__ = [];
var __$Setters__ = [];
var __$Resetters__ = [];

function __GetDependency__(name) {
    return __$Getters__[name]();
}

function __Rewire__(name, value) {
    __$Setters__[name](value);
}

function __ResetDependency__(name) {
    __$Resetters__[name]();
}

var __RewireAPI__ = {
    '__GetDependency__': __GetDependency__,
    '__get__': __GetDependency__,
    '__Rewire__': __Rewire__,
    '__set__': __Rewire__,
    '__ResetDependency__': __ResetDependency__
};
var Future = _fibersFuture2['default'];

__$Getters__['Future'] = function () {
    return Future;
};

__$Setters__['Future'] = function (value) {
    Future = value;
};

__$Resetters__['Future'] = function () {
    Future = _fibersFuture2['default'];
};

var Fiber = _fibers2['default'];

__$Getters__['Fiber'] = function () {
    return Fiber;
};

__$Setters__['Fiber'] = function (value) {
    Fiber = value;
};

__$Resetters__['Fiber'] = function () {
    Fiber = _fibers2['default'];
};

var assign = _objectAssign2['default'];

__$Getters__['assign'] = function () {
    return assign;
};

__$Setters__['assign'] = function (value) {
    assign = value;
};

__$Resetters__['assign'] = function () {
    assign = _objectAssign2['default'];
};

var SYNC_COMMANDS = ['domain', '_events', '_maxListeners', 'setMaxListeners', 'emit', 'addListener', 'on', 'once', 'removeListener', 'removeAllListeners', 'listeners', 'getMaxListeners', 'listenerCount'];

var _SYNC_COMMANDS = SYNC_COMMANDS;

__$Getters__['SYNC_COMMANDS'] = function () {
    return SYNC_COMMANDS;
};

__$Setters__['SYNC_COMMANDS'] = function (value) {
    SYNC_COMMANDS = value;
};

__$Resetters__['SYNC_COMMANDS'] = function () {
    SYNC_COMMANDS = _SYNC_COMMANDS;
};

var commandIsRunning = false;
var _commandIsRunning2 = commandIsRunning;

__$Getters__['commandIsRunning'] = function () {
    return commandIsRunning;
};

__$Setters__['commandIsRunning'] = function (value) {
    commandIsRunning = value;
};

__$Resetters__['commandIsRunning'] = function () {
    commandIsRunning = _commandIsRunning2;
};

var forcePromises = false;

var _forcePromises = forcePromises;

__$Getters__['forcePromises'] = function () {
    return forcePromises;
};

__$Setters__['forcePromises'] = function (value) {
    forcePromises = value;
};

__$Resetters__['forcePromises'] = function () {
    forcePromises = _forcePromises;
};

var isAsync = function isAsync() {
    if (!global.browser || !global.browser.options) {
        return false;
    }

    return global.browser.options.sync === false;
};

/**
 * helper method to execute a row of hooks with certain parameters
 * @param  {Function|Function[]} hooks  list of hooks
 * @param  {Object[]} args  list of parameter for hook functions
 * @return {Promise}  promise that gets resolved once all hooks finished running
 */
var _isAsync = isAsync;

__$Getters__['isAsync'] = function () {
    return isAsync;
};

__$Setters__['isAsync'] = function (value) {
    isAsync = value;
};

__$Resetters__['isAsync'] = function () {
    isAsync = _isAsync;
};

var executeHooksWithArgs = function executeHooksWithArgs(hooks, args) {
    if (hooks === undefined) hooks = [];

    /**
     * make sure hooks are an array of functions
     */
    if (typeof hooks === 'function') {
        hooks = [hooks];
    }

    /**
     * make sure args is an array since we are calling apply
     */
    if (!Array.isArray(args)) {
        args = [args];
    }

    hooks = hooks.map(function (hook) {
        return new Promise(function (resolve) {
            var _commandIsRunning = commandIsRunning;

            /**
             * no need for fiber wrap in async mode
             */
            if (isAsync()) {
                commandIsRunning = true;
                var result = resolve(hook.apply(null, args));
                commandIsRunning = _commandIsRunning;
                return result;
            }

            try {
                /**
                 * after command hooks require additional Fiber environment
                 */
                return Fiber(function () {
                    commandIsRunning = true;
                    resolve(hook.apply(null, args));
                    commandIsRunning = _commandIsRunning;
                }).run();
            } catch (e) {
                console.error(e.stack);
            }

            resolve();
        });
    });

    return Promise.all(hooks);
};

/**
 * global function to wrap callbacks into Fiber context
 * @param  {Function} fn  function to wrap around
 * @return {Function}     wrapped around function
 */
var _executeHooksWithArgs = executeHooksWithArgs;

__$Getters__['executeHooksWithArgs'] = function () {
    return executeHooksWithArgs;
};

__$Setters__['executeHooksWithArgs'] = function (value) {
    exports.executeHooksWithArgs = executeHooksWithArgs = value;
};

__$Resetters__['executeHooksWithArgs'] = function () {
    exports.executeHooksWithArgs = executeHooksWithArgs = _executeHooksWithArgs;
};

global.wdioSync = function (fn, done) {
    return function () {
        var _this = this;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return Fiber(function () {
            var result = fn.apply(_this, args);

            if (typeof done === 'function') {
                done(result);
            }
        }).run();
    };
};

/**
 * wraps a function into a Fiber ready context to enable sync execution and hooks
 * @param  {Function}   fn             function to be executed
 * @param  {String}     commandName    name of that function
 * @param  {Function[]} beforeCommand  method to be executed before calling the actual function
 * @param  {Function[]} afterCommand   method to be executed after calling the actual function
 * @return {Function}   actual wrapped function
 */
var wrapCommand = function wrapCommand(fn, commandName, beforeCommand, afterCommand) {
    if (isAsync()) {
        /**
         * async command wrap
         */
        return function () {
            for (var _len2 = arguments.length, commandArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                commandArgs[_key2] = arguments[_key2];
            }

            return fn.apply(this, commandArgs);
        };
    }

    /**
     * sync command wrap
     */
    return function () {
        var _this2 = this;

        for (var _len3 = arguments.length, commandArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            commandArgs[_key3] = arguments[_key3];
        }

        var future = new Future();
        var futureFailed = false;

        if (forcePromises) {
            return fn.apply(this, commandArgs);
        }

        /**
         * don't execute [before/after]Command hook if a command was executed
         * in these hooks (otherwise we will get into an endless loop)
         */
        if (commandIsRunning) {
            var commandPromise = fn.apply(this, commandArgs);

            /**
             * try to execute with Fibers and fall back if can't
             */
            try {
                commandPromise.then(future['return'].bind(future), future['throw'].bind(future));
                return future.wait();
            } catch (e) {
                if (e.message === "Can't wait without a fiber") {
                    return commandPromise;
                }
                throw e;
            }
        }

        commandIsRunning = true;
        var newInstance = this;
        var commandResult = undefined,
            commandError = undefined;
        new Promise(function (r) {
            return r(executeHooksWithArgs(beforeCommand, [commandName, commandArgs]));
        }).then(function () {
            /**
             * actual function was already executed in desired catch block
             */
            if (futureFailed) {
                return;
            }

            newInstance = fn.apply(_this2, commandArgs);
            return newInstance;
        }).then(function (result) {
            commandResult = result;
            return executeHooksWithArgs(afterCommand, [commandName, commandArgs, result]);
        }, function (e) {
            commandError = e;
            return executeHooksWithArgs(afterCommand, [commandName, commandArgs, null, e]);
        }).then(function () {
            commandIsRunning = false;

            if (commandError) {
                return future['throw'](commandError);
            }
            _wrapCommands2(newInstance, beforeCommand, afterCommand);
            return future['return'](applyPrototype.call(newInstance, commandResult));
        });

        /**
         * try to execute with Fibers and fall back if can't
         */
        try {
            return future.wait();
        } catch (e) {
            if (e.message === "Can't wait without a fiber") {
                futureFailed = true;
                return fn.apply(this, commandArgs);
            }
            throw e;
        }
    };
};

/**
 * enhance result with instance prototype to enable command chaining
 * @param  {Object} result   command result
 * @return {Object}          command result with enhanced prototype
 */
var _wrapCommand = wrapCommand;

__$Getters__['wrapCommand'] = function () {
    return wrapCommand;
};

__$Setters__['wrapCommand'] = function (value) {
    exports.wrapCommand = wrapCommand = value;
};

__$Resetters__['wrapCommand'] = function () {
    exports.wrapCommand = wrapCommand = _wrapCommand;
};

var applyPrototype = function applyPrototype(result) {
    if (!result || typeof result !== 'object' || Array.isArray(result)) {
        return result;
    }

    var prototype = {};
    var hasExtendedPrototype = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Object.keys(Object.getPrototypeOf(this))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var commandName = _step.value;

            if (result[commandName] || SYNC_COMMANDS.indexOf(commandName) > -1) {
                continue;
            }

            this.lastResult = result;
            prototype[commandName] = { value: this[commandName].bind(this) };
            hasExtendedPrototype = true;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    if (hasExtendedPrototype) {
        var newResult = Object.create(result, prototype);

        /**
         * since status is a command we need to rename the property
         */
        if (typeof result.status !== 'undefined') {
            result._status = result.status;
            delete result.status;
        }

        result = assign(newResult, result);
    }

    return result;
};

/**
 * wraps all WebdriverIO commands
 * @param  {Object}     instance       WebdriverIO client instance (browser)
 * @param  {Function[]} beforeCommand  before command hook
 * @param  {Function[]} afterCommand   after command hook
 */
var _applyPrototype = applyPrototype;

__$Getters__['applyPrototype'] = function () {
    return applyPrototype;
};

__$Setters__['applyPrototype'] = function (value) {
    applyPrototype = value;
};

__$Resetters__['applyPrototype'] = function () {
    applyPrototype = _applyPrototype;
};

var _wrapCommands2 = function wrapCommands(instance, beforeCommand, afterCommand) {
    /**
     * if instance is a multibrowser instance make sure to wrap commands
     * of its instances too
     */
    if (instance.isMultiremote) {
        instance.getInstances().forEach(function (browserName) {
            _wrapCommands2(global[browserName], beforeCommand, afterCommand);
        });
    }

    Object.keys(Object.getPrototypeOf(instance)).forEach(function (commandName) {
        if (SYNC_COMMANDS.indexOf(commandName) > -1) {
            return;
        }

        var origFn = instance[commandName];
        instance[commandName] = wrapCommand.call(instance, origFn, commandName, beforeCommand, afterCommand);
    });

    /**
     * no need to overwrite addCommand in async mode
     */
    if (isAsync()) {
        return;
    }

    /**
     * Adding a command within fiber context doesn't require a special routine
     * since everything runs sync. There is no need to promisify the command.
     */
    instance.addCommand = function (fnName, fn, forceOverwrite) {
        var commandGroup = instance;
        var commandName = fnName;
        var namespace = undefined;

        if (typeof fn === 'string') {
            namespace = arguments[0];
            fnName = arguments[1];
            fn = arguments[2];
            forceOverwrite = arguments[3];

            switch (typeof commandGroup[namespace]) {
                case 'function':
                    throw new Error('Command namespace "' + namespace + '" is used internally, and can\'t be overwritten!');
                case 'undefined':
                    commandGroup[namespace] = {};
                    break;
            }

            commandName = namespace + '.' + fnName;
            commandGroup = commandGroup[namespace];
        }

        if (commandGroup[fnName] && !forceOverwrite) {
            throw new Error('Command ' + fnName + ' is already defined!');
        }

        /**
         * if method name is async the user specifies that he wants to
         * use bare promises to handle asynchronicity
         */
        if (fn.name === 'async') {
            commandGroup[fnName] = wrapCommand(function () {
                for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                    args[_key4] = arguments[_key4];
                }

                forcePromises = true;
                var res = fn.apply(instance, args);
                forcePromises = false;
                return res;
            }, commandName, beforeCommand, afterCommand);
            return;
        }

        /**
         * for all other cases we internally return a promise that is
         * finished once the Fiber wrapped custom function has finished
         * #functionalProgrammingWTF!
         */
        commandGroup[fnName] = wrapCommand(function () {
            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
            }

            return new Promise(function (r) {
                wdioSync(fn, r).apply(instance, args);
            });
        }, commandName, beforeCommand, afterCommand);
    };
};

/**
 * [runInFiberContext description]
 * @param  {[type]} testInterfaceFnNames  global command that runs specs
 * @param  {[type]} before               before hook hook
 * @param  {[type]} after                after hook hook
 * @param  {[type]} fnName               test interface command to wrap
 */
var _wrapCommands = _wrapCommands2;

__$Getters__['wrapCommands'] = function () {
    return _wrapCommands2;
};

__$Setters__['wrapCommands'] = function (value) {
    _wrapCommands2 = value;
};

__$Resetters__['wrapCommands'] = function () {
    _wrapCommands2 = _wrapCommands;
};

var runInFiberContext = function runInFiberContext(testInterfaceFnNames, before, after, fnName) {
    var origFn = global[fnName];

    var runSpec = function runSpec(specTitle, specFn) {
        /**
         * user wants handle async command using promises, no need to wrap in fiber context
         */
        if (isAsync() || specFn.name === 'async') {
            return origFn.call(this, specTitle, specFn);
        }

        return origFn(specTitle, function (done) {
            var _this3 = this;

            Fiber(function () {
                specFn.call(_this3);
                done();
            }).run();
        });
    };

    var runHook = function runHook(hookFn) {
        /**
         * user wants handle async command using promises, no need to wrap in fiber context
         */
        if (isAsync() || hookFn.name === 'async') {
            return origFn(function (done) {
                var _this4 = this;

                executeHooksWithArgs(before)['catch'](function (e) {
                    console.error('Error in beforeHook: [' + e + ']');
                }).then(function () {
                    return hookFn.call(_this4);
                }).then(function () {
                    return executeHooksWithArgs(after)['catch'](function (e) {
                        console.error('Error in afterHook: [' + e + ']');
                    });
                }).then(function () {
                    return done();
                }, done);
            });
        }

        return origFn(function (done) {
            var _this5 = this;

            // Print errors encountered in beforeHook and afterHook to console, but
            // don't propagate them to avoid failing the test. However, errors in
            // framework hook functions should fail the test, so propagate those.
            executeHooksWithArgs(before)['catch'](function (e) {
                console.error('Error in beforeHook: [' + e + ']');
            }).then(function () {
                return new Promise(function (resolve, reject) {
                    return Fiber(function () {
                        try {
                            hookFn.call(_this5);
                        } catch (e) {
                            reject(e);
                        }
                        resolve();
                    }).run();
                });
            }).then(function () {
                return executeHooksWithArgs(after)['catch'](function (e) {
                    console.error('Error in afterHook: [' + e + ']');
                });
            }).then(function () {
                return done();
            }, done);
        });
    };

    global[fnName] = function () {
        for (var _len6 = arguments.length, specArguments = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            specArguments[_key6] = arguments[_key6];
        }

        /**
         * Variadic arguments: [title, fn], [title], [fn]
         */
        var specFn = typeof specArguments[0] === 'function' ? specArguments.shift() : typeof specArguments[1] === 'function' ? specArguments.pop() : undefined;
        var specTitle = specArguments[0];

        if (testInterfaceFnNames.indexOf(fnName) > -1) {
            if (specFn) return runSpec(specTitle, specFn);

            /**
             * if specFn is undefined we are dealing with a pending function
             */
            return origFn(specTitle);
        }

        return runHook(specFn);
    };

    if (testInterfaceFnNames.indexOf(fnName) > -1) {
        global[fnName].skip = origFn.skip;
        global[fnName].only = origFn.only;
    }
};

var _runInFiberContext = runInFiberContext;

__$Getters__['runInFiberContext'] = function () {
    return runInFiberContext;
};

__$Setters__['runInFiberContext'] = function (value) {
    exports.runInFiberContext = runInFiberContext = value;
};

__$Resetters__['runInFiberContext'] = function () {
    exports.runInFiberContext = runInFiberContext = _runInFiberContext;
};

exports.wrapCommand = wrapCommand;
exports.wrapCommands = _wrapCommands2;
exports.runInFiberContext = runInFiberContext;
exports.executeHooksWithArgs = executeHooksWithArgs;
exports.__GetDependency__ = __GetDependency__;
exports.__get__ = __GetDependency__;
exports.__Rewire__ = __Rewire__;
exports.__set__ = __Rewire__;
exports.__ResetDependency__ = __ResetDependency__;
exports.__RewireAPI__ = __RewireAPI__;
exports['default'] = __RewireAPI__;
